# GrayCode

```go
func toGrayCode(a byte) byte {
    return a ^ (a >> 1)
}

func restoreGrayCode(a byte) byte {
    b := a
    for a >>= 1; a > 0; a >>= 1 {
        b ^= a
    }
    return b
}
```

<hr>
<br>

格雷码（Gray Code）是一种二进制编码方式，其特点是相邻的两个数值只有一个二进制位的不同。

格雷码在软件领域中的应用并不常见，但是在硬件领域中具有重要意义。

1. 减小电路复杂性： 格雷码的特性使机械控制电路更容易处理，因为只需要关注一个位的变化，这降低了电路的复杂性和成本。

2. 减小功耗： 由于格雷码中每个值与前一个值仅有一个位的不同，因此在切换位置时的功耗较低，这对于移动部件的电能效率非常有利。

3. 减小误差传播： 在高精度机械控制应用中，减小了位置坐标之间的位切换次数，有助于减小误差的传播，提高了控制精度。

4. 抗干扰性： 格雷码对于噪声和干扰有较高的抗干扰性，因为仅有一个位的变化，这有助于保持控制系统的稳定性。

5. 方便位置检测： 由于只有一个位的变化，机械系统的当前位置可以更容易地被检测和确定，这对于反馈控制系统非常重要。

<br>

格雷编码的具体步骤如下

```
1) BIN1: 01000111  -- 'G' binary
2) BIN2: _01000111 -- 'G' >> 1
3) GRAY: 01100100  -- 'G' ^ BIN2
```
```
十进制    二进制    格雷码
  1   00000001 00000001 \_ 相邻的两个数只有一位不同
  2   00000010 00000011 /
  3   00000011 00000010
  4   00000100 00000110
  5   00000101 00000111
  6   00000110 00000101
  7   00000111 00000100
  8   00001000 00001100
  9   00001001 00001101
```

<br>

例子：二进制数据格雷编码，以及逆向还原（restoreGrayCode）

```go
BIN := []byte("Hello Gray code")
for i := 0; i < len(BIN); i++ {
    BIN[i] = toGrayCode(BIN[i])
}
```

<br>

*PS：非硬件领域从业者，偶然接触到格雷码。在此记录备忘。*
